<blocks app="Snap! 4.0, http://snap.berkeley.edu" version="1"><block-definition s="all pairs shortest paths floyd-warshall (dict)" type="reporter" category="network"><header></header><code></code><inputs></inputs><script><block s="doDeclareVariables"><list><l>distance</l></list></block><block s="doSetVar"><l>distance</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>source</l><block s="getNodes"></block><script><block s="setDict"><block var="source"/><block var="distance"/><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>destination</l><block s="getNodes"></block><script><block s="setDict"><block var="destination"/><block s="getDict"><block var="source"/><block var="distance"/></block><l>inf</l></block></script></block><block s="setDict"><block var="source"/><block s="getDict"><block var="source"/><block var="distance"/></block><l>0</l></block></script><comment w="168" collapsed="false">Initialise distances</comment></block><block s="doForEach"><l>edge</l><block s="getEdges"></block><script><block s="setDict"><block s="reportListItem"><l>2</l><block var="edge"/></block><block s="getDict"><block s="reportListItem"><l>1</l><block var="edge"/></block><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></script></block><block s="doForEach"><l>k</l><block s="getNodes"></block><script><block s="doForEach"><l>i</l><block s="getNodes"></block><script><block s="doForEach"><l>j</l><block s="getNodes"></block><script><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportEquals"><block s="getDict"><block var="k"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><l>inf</l></block></block><block s="reportNot"><block s="reportEquals"><block s="getDict"><block var="j"/><block s="getDict"><block var="k"/><block var="distance"/></block></block><l>inf</l></block></block></block><script><block s="doIfElse"><block s="reportEquals"><block var="i"/><block var="j"/></block><script><block s="doIf"><block s="reportGreaterThan"><block s="getDict"><block var="j"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="reportSum"><block s="getDict"><block var="k"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="getDict"><block var="j"/><block s="getDict"><block var="k"/><block var="distance"/></block></block></block></block><script><block s="doReport"><l>Error: Negative cost cycle</l></block></script><comment w="90" collapsed="false">Detect negative cost cycles. If the path i-i can be improved by i-k, k-i then there must be a negative cost cycle.</comment></block></script><script><block s="doIfElse"><block s="reportEquals"><block s="getDict"><block var="j"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><l>inf</l></block><script><block s="setDict"><block var="j"/><block s="getDict"><block var="i"/><block var="distance"/></block><block s="reportSum"><block s="getDict"><block var="k"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="getDict"><block var="j"/><block s="getDict"><block var="k"/><block var="distance"/></block></block></block></block></script><script><block s="doIf"><block s="reportGreaterThan"><block s="getDict"><block var="j"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="reportSum"><block s="getDict"><block var="k"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="getDict"><block var="j"/><block s="getDict"><block var="k"/><block var="distance"/></block></block></block></block><script><block s="setDict"><block var="j"/><block s="getDict"><block var="i"/><block var="distance"/></block><block s="reportSum"><block s="getDict"><block var="k"/><block s="getDict"><block var="i"/><block var="distance"/></block></block><block s="getDict"><block var="j"/><block s="getDict"><block var="k"/><block var="distance"/></block></block></block></block></script></block></script></block></script></block></script></block></script></block></script></block></script></block><block s="doReport"><block var="distance"/></block></script><scripts><comment x="483" y="245.79999999999984" w="123" collapsed="false">Optimal substructure:&#xD;For a source vertex i and destination vertex j, let P be the shortest cycle-free i-j path containing only the first k vertices, then either&#xD;- If vertex k is not internal to P then P is the shortest path containing the first k-1 verticies.&#xD;- If vertex k is internal to P then P_i is the shortest path i-k path containing only the first k-1 vertices and P_j is the shortest k-j path containing only the first k-1 verticies.</comment></scripts><password></password><salt></salt></block-definition><block-definition s="all pairs shortest paths floyd-warshall (list)" type="reporter" category="network"><header></header><code></code><inputs></inputs><script><block s="doDeclareVariables"><list><l>distance</l></list></block><block s="doSetVar"><l>distance</l><block s="reportNewList"><list></list></block></block><block s="doForEach"><l>source</l><block s="getNodes"></block><script><block s="doAddToList"><block s="reportNewList"><list></list></block><block var="distance"/></block><block s="doForEach"><l>destination</l><block s="getNodes"></block><script><block s="doAddToList"><l>inf</l><block s="reportListItem"><block var="source"/><block var="distance"/></block></block></script></block><block s="doReplaceInList"><block var="source"/><block s="reportListItem"><block var="source"/><block var="distance"/></block><l>0</l></block></script><comment w="168" collapsed="false">Initialise distances</comment></block><block s="doForEach"><l>edge</l><block s="getEdges"></block><script><block s="doReplaceInList"><block s="reportListItem"><l>2</l><block var="edge"/></block><block s="reportListItem"><block s="reportListItem"><l>1</l><block var="edge"/></block><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></script></block><block s="doNumericFor"><l>k</l><l>1</l><block s="numberOfNodes"></block><script><block s="doNumericFor"><l>i</l><l>1</l><block s="numberOfNodes"></block><script><block s="doNumericFor"><l>j</l><l>1</l><block s="numberOfNodes"></block><script><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportEquals"><block s="reportListItem"><block var="k"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><l>inf</l></block></block><block s="reportNot"><block s="reportEquals"><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="k"/><block var="distance"/></block></block><l>inf</l></block></block></block><script><block s="doIfElse"><block s="reportEquals"><block var="i"/><block var="j"/></block><script><block s="doIf"><block s="reportGreaterThan"><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportSum"><block s="reportListItem"><block var="k"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="k"/><block var="distance"/></block></block></block></block><script><block s="doReport"><l>Error: Negative cost cycle</l></block></script><comment w="90" collapsed="false">Detect negative cost cycles. If the path i-i can be improved by i-k, k-i then there must be a negative cost cycle.</comment></block></script><script><block s="doIfElse"><block s="reportEquals"><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><l>inf</l></block><script><block s="doReplaceInList"><block var="j"/><block s="reportListItem"><block var="i"/><block var="distance"/></block><block s="reportSum"><block s="reportListItem"><block var="k"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="k"/><block var="distance"/></block></block></block></block></script><script><block s="doIf"><block s="reportGreaterThan"><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportSum"><block s="reportListItem"><block var="k"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="k"/><block var="distance"/></block></block></block></block><script><block s="doReplaceInList"><block var="j"/><block s="reportListItem"><block var="i"/><block var="distance"/></block><block s="reportSum"><block s="reportListItem"><block var="k"/><block s="reportListItem"><block var="i"/><block var="distance"/></block></block><block s="reportListItem"><block var="j"/><block s="reportListItem"><block var="k"/><block var="distance"/></block></block></block></block></script></block></script></block></script></block></script></block></script></block></script></block></script></block><block s="doReport"><block var="distance"/></block></script><scripts><comment x="474.000003" y="192.2" w="123" collapsed="false">Optimal substructure:&#xD;For a source vertex i and destination vertex j, let P be the shortest cycle-free i-j path containing only the first k vertices, then either&#xD;- If vertex k is not internal to P then P is the shortest path containing the first k-1 verticies.&#xD;- If vertex k is internal to P then P_i is the shortest path i-k path containing only the first k-1 vertices and P_j is the shortest k-j path containing only the first k-1 verticies.</comment></scripts><password></password><salt></salt></block-definition></blocks>