<blocks app="Snap! 4.0, http://snap.berkeley.edu" version="1"><block-definition s="all single source shortest paths bellman-ford from node %&apos;source&apos;" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>distance</l><l>predecessor</l><l>head</l><l>tail</l></list></block><block s="doSetVar"><l>distance</l><block s="reportNewDict"><list></list></block></block><block s="doSetVar"><l>predecessor</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="doIfElse"><block s="reportEquals"><block var="node"/><block var="source"/></block><script><block s="setDict"><block var="node"/><block var="distance"/><l>0</l></block></script><script><block s="setDict"><block var="node"/><block var="distance"/><l>inf</l></block></script></block><block s="setDict"><block var="node"/><block var="predecessor"/><l>undefined</l></block></script><comment w="90" collapsed="false">Initialise distance and predecessor dictionaries. If nodes were indexed with numbers, could use a list.</comment></block><block s="doNumericFor"><l>i</l><l>1</l><block s="reportDifference"><block s="numberOfNodes"></block><l>1</l></block><script><block s="doForEach"><l>edge</l><block s="getEdges"></block><script><block s="doSetVar"><l>head</l><block s="reportListItem"><l>2</l><block var="edge"/></block></block><block s="doSetVar"><l>tail</l><block s="reportListItem"><l>1</l><block var="edge"/></block></block><block s="doIf"><block s="reportNot"><block s="reportEquals"><block s="getDict"><block var="tail"/><block var="distance"/></block><l>inf</l></block></block><script><block s="doIfElse"><block s="reportEquals"><block s="getDict"><block var="head"/><block var="distance"/></block><l>inf</l></block><script><block s="setDict"><block var="head"/><block var="distance"/><block s="reportSum"><block s="getDict"><block var="tail"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></block><block s="setDict"><block var="head"/><block var="predecessor"/><block var="tail"/></block></script><script><block s="doIf"><block s="reportLessThan"><block s="reportSum"><block s="getDict"><block var="tail"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block><block s="getDict"><block var="head"/><block var="distance"/></block></block><script><block s="setDict"><block var="head"/><block var="distance"/><block s="reportSum"><block s="getDict"><block var="tail"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></block><block s="setDict"><block var="head"/><block var="predecessor"/><block var="tail"/></block></script><comment w="124" collapsed="false">Optimal substructure:&#xD;If P is the shortest s-v path with at most i edges then either&#xD;- P has less than i edges, in which case it is the shortest path with at most i-1 edges.&#xD;- P has exactly i edges and contains as its last hop the edge (u,v) and P&apos; is the shortest path from s-u with at most i-1 edges.</comment></block></script></block></script></block></script></block></script><comment w="90" collapsed="false">Each minimum length path has at most n-1 edges. Recursively calculate the shortest path with at most i edges</comment></block><block s="doForEach"><l>edge</l><block s="getEdges"></block><script><block s="doSetVar"><l>head</l><block s="reportListItem"><l>2</l><block var="edge"/></block></block><block s="doSetVar"><l>tail</l><block s="reportListItem"><l>1</l><block var="edge"/></block></block><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportEquals"><block s="getDict"><block var="tail"/><block var="distance"/></block><l>inf</l></block></block><block s="reportNot"><block s="reportEquals"><block s="getDict"><block var="head"/><block var="distance"/></block><l>inf</l></block></block></block><script><block s="doIf"><block s="reportLessThan"><block s="reportSum"><block s="getDict"><block var="tail"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block><block s="getDict"><block var="head"/><block var="distance"/></block></block><script><block s="doReport"><l>Error: Negative cost cycle</l></block></script><comment w="145" collapsed="false">If any paths get cheaper by including n edges then there must be a negative cost cycle.</comment></block></script></block></script></block><block s="doReport"><block s="reportNewList"><list><block var="distance"/><block var="predecessor"/></list></block></block></script><password></password><salt></salt></block-definition></blocks>