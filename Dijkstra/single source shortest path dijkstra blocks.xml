<blocks app="Snap! 4.0, http://snap.berkeley.edu" version="1"><block-definition s="empty priority queue" type="reporter" category="collections"><header></header><code></code><inputs></inputs><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewDict"><list></list></block></list></block><comment w="90" collapsed="false">An empty priority queue is an empty list.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="push %&apos;object&apos; with priority %&apos;priority&apos; to priority queue %&apos;pqueue&apos;" type="command" category="collections"><header></header><code></code><inputs><input type="%s"></input><input type="%n"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l><l>parent index</l><l>value</l><l>index map</l></list></block><block s="doSetVar"><l>index map</l><block s="reportListItem"><l>1</l><block var="pqueue"/></block></block><block s="doAddToList"><block s="reportNewList"><list><block var="priority"/><block var="object"/></list></block><block var="pqueue"/><comment w="90" collapsed="true">Adds new object to end of queue. Objects are stored as a (priority,object) tuple.</comment></block><block s="setDict"><block var="object"/><block var="index map"/><block s="reportListLength"><block var="pqueue"/></block></block><block s="doSetVar"><l>index</l><block s="reportListLength"><block var="pqueue"/></block></block><block s="doSetVar"><l>parent index</l><block s="reportSum"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block s="reportDifference"><block var="index"/><l>1</l></block><l>2</l></block></block><l>1</l></block><comment w="90" collapsed="true">Objects are stored as a binary heap in an array...</comment></block><block s="doIf"><block s="reportNot"><block s="reportEquals"><block var="index"/><l>2</l></block><comment w="90" collapsed="true">If there was already items in the queue ...</comment></block><script><block s="doUntil"><block s="reportOr"><block s="reportEquals"><block var="index"/><l>2</l></block><block s="reportLessThan"><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block></block></block><script><block s="doSetVar"><l>value</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="index"/><block var="pqueue"/><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="parent index"/><block var="pqueue"/><block var="value"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block var="index map"/><block var="index"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block var="index map"/><block var="parent index"/></block><block s="doSetVar"><l>index</l><block var="parent index"/></block><block s="doSetVar"><l>parent index</l><block s="reportSum"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block s="reportDifference"><block var="index"/><l>1</l></block><l>2</l></block></block><l>1</l></block></block></script><comment w="90" collapsed="true">Check that heap inequality is maintained by the new item. If not, swap it up the queue until it is.</comment></block></script></block></script><password></password><salt></salt></block-definition><block-definition s="pop min from priority queue %&apos;pqueue&apos;" type="reporter" category="collections"><header></header><code></code><inputs><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>return value</l><l>index map</l></list></block><block s="doSetVar"><l>index map</l><block s="reportListItem"><l>1</l><block var="pqueue"/></block></block><block s="doIf"><block s="reportEquals"><block s="reportListLength"><block var="pqueue"/></block><l>1</l></block><script><block s="doReport"><l>Error: Priority queue empty</l></block></script></block><block s="doSetVar"><l>return value</l><block s="reportListItem"><l>2</l><block s="reportListItem"><l>2</l><block var="pqueue"/></block></block><comment w="90" collapsed="true">Take the first item off the queue</comment></block><block s="doReplaceInList"><l>2</l><block var="pqueue"/><block s="reportListItem"><l><option>last</option></l><block var="pqueue"/></block><comment w="90" collapsed="false">Swap last item of queue into first position</comment></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><l>2</l><block var="pqueue"/></block></block><block var="index map"/><l>2</l></block><block s="doDeleteFromList"><l><option>last</option></l><block var="pqueue"/></block><custom-block s="priority queue %s heapify down from index %n"><block var="pqueue"/><l>2</l><comment w="90" collapsed="false">Restore heap property</comment></custom-block><block s="doReport"><block var="return value"/></block></script><scripts><comment x="359" y="53.19999999999999" w="167" collapsed="false">Need to remove deleted key from index map, but no block to delete keys from a dictionary</comment></scripts><password></password><salt></salt></block-definition><block-definition s="priority queue %&apos;pqueue&apos; is empty" type="predicate" category="collections"><header></header><code></code><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportEquals"><block s="reportListLength"><block var="pqueue"/></block><l>1</l></block></block></script><password></password><salt></salt></block-definition><block-definition s="priority queue %&apos;pqueue&apos; heapify down from index %&apos;index&apos;" type="command" category="collections"><header></header><code></code><inputs><input type="%s"></input><input type="%n"></input></inputs><script><block s="doDeclareVariables"><list><l>left</l><l>right</l><l>smallest</l><l>value</l><l>index map</l></list></block><block s="doSetVar"><l>index map</l><block s="reportListItem"><l>1</l><block var="pqueue"/></block></block><block s="doSetVar"><l>left</l><block s="reportSum"><block s="reportProduct"><l>2</l><block s="reportDifference"><block var="index"/><l>1</l></block></block><l>1</l></block></block><block s="doSetVar"><l>right</l><block s="reportSum"><block s="reportProduct"><l>2</l><block s="reportDifference"><block var="index"/><l>1</l></block></block><l>2</l></block></block><block s="doSetVar"><l>smallest</l><block var="index"/></block><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportGreaterThan"><block var="left"/><block s="reportListLength"><block var="pqueue"/></block></block></block><block s="reportLessThan"><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="left"/><block var="pqueue"/></block></block><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="smallest"/><block var="pqueue"/></block></block></block></block><script><block s="doSetVar"><l>smallest</l><block var="left"/></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportGreaterThan"><block var="right"/><block s="reportListLength"><block var="pqueue"/></block></block></block><block s="reportLessThan"><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="right"/><block var="pqueue"/></block></block><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="smallest"/><block var="pqueue"/></block></block></block></block><script><block s="doSetVar"><l>smallest</l><block var="right"/></block></script></block><block s="doIf"><block s="reportNot"><block s="reportEquals"><block var="smallest"/><block var="index"/></block></block><script><block s="doSetVar"><l>value</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="index"/><block var="pqueue"/><block s="reportListItem"><block var="smallest"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="smallest"/><block var="pqueue"/><block var="value"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="smallest"/><block var="pqueue"/></block></block><block var="index map"/><block var="smallest"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block var="index map"/><block var="index"/></block><custom-block s="priority queue %s heapify down from index %n"><block var="pqueue"/><block var="smallest"/><comment w="90" collapsed="false">If a swap was done, check the new children</comment></custom-block></script><comment w="90" collapsed="false">If item at index has a higher priority than either of its children then swap it with the lowest priority child.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="decrease priority of %&apos;key&apos; to %&apos;priority&apos; in priority queue %&apos;pqueue&apos;" type="command" category="collections"><header></header><code></code><inputs><input type="%s"></input><input type="%n"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>index map</l><l>index</l></list></block><block s="doSetVar"><l>index map</l><block s="reportListItem"><l>1</l><block var="pqueue"/></block></block><block s="doSetVar"><l>index</l><block s="getDict"><block var="key"/><block var="index map"/></block><comment w="90" collapsed="true">Need to test if key is in dictionary before searching.</comment></block><block s="doIf"><block s="reportLessThan"><block var="priority"/><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block></block><script><block s="doReplaceInList"><l>1</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block><block var="priority"/></block><custom-block s="priority queue %s heapify up from index %n"><block var="pqueue"/><block var="index"/><comment w="90" collapsed="true">Restore heap property</comment></custom-block></script><comment w="90" collapsed="true">Only allow decrease in priority.</comment></block></script><scripts><script x="50" y="446.99999999999994"><block s="doReport"><block var="return value"/></block></script></scripts><password></password><salt></salt></block-definition><block-definition s="priority queue %&apos;pqueue&apos; heapify up from index %&apos;index&apos;" type="command" category="collections"><header></header><code></code><inputs><input type="%s"></input><input type="%n"></input></inputs><script><block s="doDeclareVariables"><list><l>index map</l><l>parent index</l><l>value</l></list></block><block s="doSetVar"><l>index map</l><block s="reportListItem"><l>1</l><block var="pqueue"/></block></block><block s="doSetVar"><l>parent index</l><block s="reportSum"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block s="reportDifference"><block var="index"/><l>1</l></block><l>2</l></block></block><l>1</l></block><comment w="90" collapsed="true">Objects are stored as a binary heap in an array...</comment></block><block s="doUntil"><block s="reportOr"><block s="reportEquals"><block var="index"/><l>2</l></block><block s="reportLessThan"><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block s="reportListItem"><l>1</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block></block></block><script><block s="doSetVar"><l>value</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="index"/><block var="pqueue"/><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block s="doReplaceInList"><block var="parent index"/><block var="pqueue"/><block var="value"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="index"/><block var="pqueue"/></block></block><block var="index map"/><block var="index"/></block><block s="setDict"><block s="reportListItem"><l>2</l><block s="reportListItem"><block var="parent index"/><block var="pqueue"/></block></block><block var="index map"/><block var="parent index"/></block><block s="doSetVar"><l>index</l><block var="parent index"/></block><block s="doSetVar"><l>parent index</l><block s="reportSum"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block s="reportDifference"><block var="index"/><l>1</l></block><l>2</l></block></block><l>1</l></block></block></script><comment w="90" collapsed="true">Check that heap inequality is maintained by the new item. If not, swap it up the queue until it is.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="Single Source Shortest Path from %&apos;start node&apos; using Dijkstra" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>distance</l><l>predecessor</l><l>node queue</l><l>node</l><l>visited</l><l>edge head</l></list></block><block s="doSetVar"><l>distance</l><block s="reportNewDict"><list></list></block></block><block s="doSetVar"><l>predecessor</l><block s="reportNewDict"><list></list></block></block><block s="doSetVar"><l>visited</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>item</l><block s="getNodes"></block><script><block s="setDict"><block var="item"/><block var="distance"/><l>inf</l></block><block s="setDict"><block var="item"/><block var="predecessor"/><l>undefined</l></block><block s="setDict"><block var="item"/><block var="visited"/><block s="reportFalse"></block></block></script><comment w="90" collapsed="false">Initialise distance, path tracking and visited lists</comment></block><block s="setDict"><block var="start node"/><block var="distance"/><l>0</l></block><block s="doSetVar"><l>node queue</l><custom-block s="empty priority queue"></custom-block></block><custom-block s="push %s with priority %n to priority queue %s"><block var="start node"/><l>0</l><block var="node queue"/></custom-block><block s="doUntil"><custom-block s="priority queue %s is empty"><block var="node queue"/></custom-block><script><block s="doSetVar"><l>node</l><custom-block s="pop min from priority queue %s"><block var="node queue"/></custom-block></block><block s="setDict"><block var="node"/><block var="visited"/><block s="reportTrue"></block></block><block s="doForEach"><l>edge</l><block s="getNeighborEdges"><block var="node"/></block><script><block s="doSetVar"><l>edge head</l><block s="reportListItem"><l>2</l><block var="edge"/></block></block><block s="doIf"><block s="reportLessThan"><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block><l>0</l><comment w="90" collapsed="false">Edge weights must be non-negative.</comment></block><script><block s="doReport"><l>Error, Negative edge weight</l></block></script></block><block s="doIf"><block s="reportNot"><block s="getDict"><block var="edge head"/><block var="visited"/></block></block><script><block s="doIfElse"><block s="reportEquals"><block s="getDict"><block var="edge head"/><block var="distance"/></block><l>inf</l></block><script><block s="setDict"><block var="edge head"/><block var="distance"/><block s="reportSum"><block s="getDict"><block var="node"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></block><block s="setDict"><block var="edge head"/><block var="predecessor"/><block var="node"/></block><custom-block s="push %s with priority %n to priority queue %s"><block var="edge head"/><block s="getDict"><block var="edge head"/><block var="distance"/></block><block var="node queue"/></custom-block></script><script><block s="doIf"><block s="reportLessThan"><block s="reportSum"><block s="getDict"><block var="node"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block><block s="getDict"><block var="edge head"/><block var="distance"/></block></block><script><block s="setDict"><block var="edge head"/><block var="distance"/><block s="reportSum"><block s="getDict"><block var="node"/><block var="distance"/></block><block s="getEdgeAttrib"><l>label</l><block var="edge"/></block></block></block><block s="setDict"><block var="edge head"/><block var="predecessor"/><block var="node"/></block><custom-block s="decrease priority of %s to %n in priority queue %s"><block var="edge head"/><block s="getDict"><block var="edge head"/><block var="distance"/></block><block var="node queue"/></custom-block></script><comment w="90" collapsed="false">Otherwise, only update if this is a cheaper path than that already found.</comment></block></script><comment w="90" collapsed="false">If first time seeing node then add it to queue.</comment></block></script></block></script></block></script></block><block s="doReport"><block s="reportNewList"><list><block var="distance"/><block var="predecessor"/></list></block></block></script><scripts><script x="381.000001" y="412.00000100000005"><block s="getOutgoingEdges"><l></l><comment w="90" collapsed="false">For directed graph change to outgoing edges</comment></block></script></scripts><password></password><salt></salt></block-definition></blocks>