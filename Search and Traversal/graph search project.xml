<project name="graph search" app="Snap! 4.0, http://snap.berkeley.edu" version="1" uuid="5d6a9ce0-b1e6-11e4-9668-33ca6eafbae9"><notes>Greg Breese</notes><thumbnail>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4CAYAAAB1ovlvAAAFRklEQVR4Xu3aX2ydcxzH8c9zOqPzb7XsxvytRoawNW1G3KyV2ISRYOJGxmJIXGCIhNpMZ7uSDRcSG1GLGzEkUjFtYnUjLKUrkQpVf+uGrWyzEe3zyHmOMy3m2JNf8nl6zvtc9fT093yf5/17pe152ihJkkQ8KGAqEAHQVJ6xaQEAAsFaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMByAGrAUAaM3PcABiwFoAgNb8DAcgBqwFAGjNz3AAYsBaAIDW/AwHIAasBQBozc9wAGLAWgCA1vwMzy3Anw6Mq2HZznSHxrrbNfuEGexWFRbILcCorXdK7qTv8irMzyXlGmAh3Z9IsRIBsDqx5hLgLwdj/R7HmnNVX1p9zxttOqYgHT+LH8PVxjB3AK9fM6hX1i9IO+8/MK5Y0sl//v63fO1H2t55UbXtQU1fjx3gCzu+181XnJpuQs+uPVqyaM5/bshb7+/V0otPSb9m8tqa3sVpfPFWgOU3GpGk+G9vMq59aLde27gwTXvdw4N69bHSd8Xyo9DWo0TFleL3QwAefYG2u/v1zuCYZijSRJKovblB9ceW3nYUH4d+jVV/XOn55I/T57/F6hsYU6FQ0HgSa/GCBvU92Xr0J8EKewHbd8Dyfb4oSd/o/uM7YKUydeltmkSxIu4TVoqV49dtAItNigifePlrrVt5TppoZPSQGufV66b1H+vFNRdOybZiwyfa1nGBhr89qKbTZ6WvrXv+C91zw5ncpM4xsEqnZgVYPrkN275Ux4qz06dL7/tQG29rVMv82VPOvX/oZz24dVi9m1rSz3d2jWjtLY2Vro/Xc14gFwC3vP6dbr/mtMOpPvh0n1rmnzQl3cBn+9R87l+fe657VLcum5fzvJxepQK5ADj5JO94fEjP3H9e+qmuN0eVJJFWXlm6TXPnpiE9fW/pNR7VUSA3AJ/a/o3uWn6G3u7fq8taS/f5ihjjONHWB85Pn/fs+kFLFs3V5pe+0uobz6qOHajxq8gNwI4tn2vmzDo9UuH3uke7RjQxHqtzVVONb111XH4uABbv6bWv7leU3lhOjnhLpm5xr5Ko+BXSzs2tamtuqI5dqOGryAXA8l9Eiv9qMCHp6kvn/uuWdL/7owqKVPoLMX8BqQa3uQC4e3i/mle9d7jnkf71avL/CA48e4kWNp1YDXtQ09eQC4DlHSj+KK70Y/X/fE1N7+g0u/hcAZxm7TjdAAUAGCAih8heAIDZ27EyQAEABojIIbIXAGD2dqwMUACAASJyiOwFAJi9HSsDFABggIgcInsBAGZvx8oABQAYICKHyF4AgNnbsTJAAQAGiMghshcAYPZ2rAxQAIABInKI7AUAmL0dKwMUAGCAiBwiewEAZm/HygAFABggIofIXgCA2duxMkABAAaIyCGyFwBg9nasDFDgD0F4treuTyufAAAAAElFTkSuQmCC</thumbnail><stage name="Stage" width="480" height="360" costume="0" tempo="60" threadsafe="false" lines="round" codify="false" scheduled="false" id="1"><pentrails>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAFoCAYAAACPNyggAAAOhUlEQVR4Xu3VwQkAAAjEMN1/abewn7jAQRC64wgQIECAAIF3gX1fNEiAAAECBAiMAHsCAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQIHLFxAWmhEwHPAAAAAElFTkSuQmCC</pentrails><costumes><list id="2"></list></costumes><sounds><list id="3"></list></sounds><variables></variables><blocks></blocks><scripts><script x="85" y="64"><custom-block s="is %s connected to %s ( BFS graphical )"><l></l><l></l></custom-block></script></scripts><sprites><sprite name="Graph" idx="1" x="-120" y="-90" heading="280" scale="1" rotation="1" draggable="false" costume="0" color="0,63.290999999999976,186.15" pen="tip" id="11"><costumes><list id="12"></list></costumes><sounds><list id="13"></list></sounds><variables></variables><blocks></blocks><scripts><script x="90" y="89"><block s="receiveGo"></block><block s="newGraph"></block><block s="generateBalancedTree"><l>2</l><l>3</l><l>1</l></block><block s="doSayFor"><l></l><l>2</l></block></script><script x="69" y="353"><custom-block s="find path from %s to %s ( BFS )"><l></l><l></l></custom-block></script><script x="67.000001" y="331.000001"><custom-block s="find path from %s to %s ( DFS )"><l>4</l><l>11</l></custom-block></script><script x="69.000001" y="299.000001"><custom-block s="find path from %s to %s ( DFS graphical )"><l>5</l><l>6</l></custom-block></script><script x="70.000001" y="274.000001"><custom-block s="find path from %s to %s ( BFS graphical )"><l>1</l><l>6</l></custom-block></script><script x="93.000001" y="238.000001"><custom-block s="is %s connected to %s ( DFS graphical )"><l>2</l><l>12</l></custom-block></script><script x="92.000001" y="211.000001"><custom-block s="is %s connected to %s ( BFS graphical )"><l>2</l><l>12</l></custom-block></script><comment x="446" y="204" w="179" collapsed="false">Predicate blocks return true or false indicating the existance of a path.&#xD;&#xD;Reporter blocks return either the path as a list or an empty list if no path exists.&#xD;&#xD;Graphical blocks color the nodes to demonstrate the order they are visited. A 1 sec wait is included for demos.&#xD;&#xD;Non-graphical blocks have no wait and no graphics. They are intended to be faster, and so useful for solving larger graphs.</comment></scripts><graph>{&quot;directed&quot;:false,&quot;multigraph&quot;:false,&quot;graph&quot;:[[&quot;__costumes__&quot;,{}]],&quot;nodes&quot;:[{&quot;id&quot;:1,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:2,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:3,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:4,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:5,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:6,&quot;color&quot;:&quot;#FF5555&quot;},{&quot;id&quot;:7,&quot;color&quot;:&quot;#FFAAAA&quot;},{&quot;id&quot;:8,&quot;color&quot;:&quot;#FFAAAA&quot;},{&quot;id&quot;:9,&quot;color&quot;:&quot;#FFAAAA&quot;},{&quot;id&quot;:10,&quot;color&quot;:&quot;#FFAAAA&quot;},{&quot;id&quot;:11,&quot;color&quot;:&quot;#FFAAAA&quot;},{&quot;id&quot;:12,&quot;color&quot;:&quot;white&quot;},{&quot;id&quot;:13,&quot;color&quot;:&quot;white&quot;},{&quot;id&quot;:14,&quot;color&quot;:&quot;white&quot;},{&quot;id&quot;:15,&quot;color&quot;:&quot;white&quot;}],&quot;links&quot;:[{&quot;source&quot;:0,&quot;target&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:2},{&quot;source&quot;:1,&quot;target&quot;:3},{&quot;source&quot;:1,&quot;target&quot;:4},{&quot;source&quot;:2,&quot;target&quot;:5},{&quot;source&quot;:2,&quot;target&quot;:6},{&quot;source&quot;:3,&quot;target&quot;:7},{&quot;source&quot;:3,&quot;target&quot;:8},{&quot;source&quot;:4,&quot;target&quot;:9},{&quot;source&quot;:4,&quot;target&quot;:10},{&quot;source&quot;:5,&quot;target&quot;:11},{&quot;source&quot;:5,&quot;target&quot;:12},{&quot;source&quot;:6,&quot;target&quot;:13},{&quot;source&quot;:6,&quot;target&quot;:14}]}</graph><nodeattrs></nodeattrs><edgeattrs></edgeattrs></sprite></sprites><nodeattrs></nodeattrs><edgeattrs></edgeattrs></stage><hidden></hidden><headers></headers><code></code><blocks><block-definition s="is %&apos;start&apos; connected to %&apos;end&apos; ( BFS graphical )" type="predicate" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end node is found, return true</comment></block><script><block s="doReport"><block s="reportTrue"></block></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportFalse"></block><comment w="90" collapsed="false">If queue is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="is %&apos;start&apos; connected to %&apos;end&apos; ( DFS graphical )" type="predicate" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doReport"><block s="reportTrue"></block></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportFalse"></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( BFS graphical )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l><l>predecessor dict</l><l>path</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end is found then backtrack through parent nodes to determine path.</comment></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( DFS graphical )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l><l>predecessor dict</l><l>path</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( DFS )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l><l>predecessor dict</l><l>path</l><l>seen nodes</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and set all nodes as not yet seen.</comment></block><block s="doSetVar"><l>seen nodes</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setDict"><block var="node"/><block var="seen nodes"/><block s="reportFalse"></block></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="setDict"><block var="start"/><block var="seen nodes"/><block s="reportTrue"></block></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportNot"><block s="getDict"><block var="neighbour"/><block var="seen nodes"/></block></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block><block s="setDict"><block var="neighbour"/><block var="seen nodes"/><block s="reportTrue"></block></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( BFS )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l><l>predecessor dict</l><l>path</l><l>seen nodes</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and set all nodes as not seen.</comment></block><block s="doSetVar"><l>seen nodes</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setDict"><block var="node"/><block var="seen nodes"/><block s="reportFalse"></block></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="setDict"><block var="start"/><block var="seen nodes"/><block s="reportTrue"></block></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end is found then backtrack through parent nodes to determine path.</comment></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportNot"><block s="getDict"><block var="neighbour"/><block var="seen nodes"/></block></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block><block s="setDict"><block var="neighbour"/><block var="seen nodes"/><block s="reportTrue"></block></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block></block></script><password></password><salt></salt></block-definition></blocks><variables></variables></project>