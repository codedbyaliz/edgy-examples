<blocks app="Snap! 4.0, http://snap.berkeley.edu" version="1"><block-definition s="is %&apos;start&apos; connected to %&apos;end&apos; ( BFS graphical )" type="predicate" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end node is found, return true</comment></block><script><block s="doReport"><block s="reportTrue"></block></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportFalse"></block><comment w="90" collapsed="false">If queue is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="is %&apos;start&apos; connected to %&apos;end&apos; ( DFS graphical )" type="predicate" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doReport"><block s="reportTrue"></block></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportFalse"></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( BFS graphical )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l><l>predecessor dict</l><l>path</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end is found then backtrack through parent nodes to determine path.</comment></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( DFS graphical )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l><l>predecessor dict</l><l>path</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and color of all nodes to white..</comment></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setNodeAttrib"><l>color</l><block var="node"/><l>white</l></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doWait"><l>1</l></block><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="current"/><l>#FF5555</l></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportEquals"><block s="getNodeAttrib"><l>color</l><block var="neighbour"/></block><l>white</l></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setNodeAttrib"><l>color</l><block var="neighbour"/><l>#FFAAAA</l></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( DFS )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node stack</l><l>current</l><l>predecessor dict</l><l>path</l><l>seen nodes</l></list></block><block s="doSetVar"><l>node stack</l><block s="reportNewStack"><list></list></block><comment w="90" collapsed="false">Initialise empty stack and set all nodes as not yet seen.</comment></block><block s="doSetVar"><l>seen nodes</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setDict"><block var="node"/><block var="seen nodes"/><block s="reportFalse"></block></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushStack"><block var="start"/><block var="node stack"/><comment w="90" collapsed="false">Start with the initial node on the stack.</comment></block><block s="setDict"><block var="start"/><block var="seen nodes"/><block s="reportTrue"></block></block><block s="doUntil"><block s="isStackEmpty"><block var="node stack"/></block><script><block s="doSetVar"><l>current</l><block s="reportStackTop"><block var="node stack"/></block><comment w="90" collapsed="false">Take top node off stack</comment></block><block s="popStack"><block var="node stack"/></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script><comment w="90" collapsed="false">If end node is found, return true</comment></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportNot"><block s="getDict"><block var="neighbour"/><block var="seen nodes"/></block></block><script><block s="pushStack"><block var="neighbour"/><block var="node stack"/></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block><block s="setDict"><block var="neighbour"/><block var="seen nodes"/><block s="reportTrue"></block></block></script></block></script><comment w="90" collapsed="false">Add any previously unseen neighbours to the stack..</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block><comment w="90" collapsed="false">If stack is empty before we find the end then start and end are not connected.</comment></block></script><password></password><salt></salt></block-definition><block-definition s="find path from %&apos;start&apos; to %&apos;end&apos; ( BFS )" type="reporter" category="network"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>node queue</l><l>current</l><l>predecessor dict</l><l>path</l><l>seen nodes</l></list></block><block s="doSetVar"><l>node queue</l><block s="reportNewQueue"><list></list></block><comment w="90" collapsed="false">Initialise empty queue and set all nodes as not seen.</comment></block><block s="doSetVar"><l>seen nodes</l><block s="reportNewDict"><list></list></block></block><block s="doForEach"><l>node</l><block s="getNodes"></block><script><block s="setDict"><block var="node"/><block var="seen nodes"/><block s="reportFalse"></block></block></script></block><block s="doSetVar"><l>predecessor dict</l><block s="reportNewDict"><list></list></block></block><block s="pushQueue"><block var="start"/><block var="node queue"/><comment w="90" collapsed="false">Start with the initial node on the queue.</comment></block><block s="setDict"><block var="start"/><block var="seen nodes"/><block s="reportTrue"></block></block><block s="doUntil"><block s="isQueueEmpty"><block var="node queue"/></block><script><block s="doSetVar"><l>current</l><block s="reportQueueTop"><block var="node queue"/></block><comment w="90" collapsed="false">Take the top node off the queue</comment></block><block s="popQueue"><block var="node queue"/></block><block s="doIf"><block s="reportEquals"><block var="current"/><block var="end"/><comment w="90" collapsed="false">If end is found then backtrack through parent nodes to determine path.</comment></block><script><block s="doSetVar"><l>path</l><block s="reportNewList"><list><block var="end"/></list></block></block><block s="doUntil"><block s="reportEquals"><block var="current"/><block var="start"/></block><script><block s="doSetVar"><l>current</l><block s="getDict"><block var="current"/><block var="predecessor dict"/></block></block><block s="doInsertInList"><block var="current"/><l>1</l><block var="path"/></block></script></block><block s="doReport"><block var="path"/></block></script></block><block s="doForEach"><l>neighbour</l><block s="getNeighbors"><block var="current"/></block><script><block s="doIf"><block s="reportNot"><block s="getDict"><block var="neighbour"/><block var="seen nodes"/></block></block><script><block s="pushQueue"><block var="neighbour"/><block var="node queue"/></block><block s="setDict"><block var="neighbour"/><block var="predecessor dict"/><block var="current"/></block><block s="setDict"><block var="neighbour"/><block var="seen nodes"/><block s="reportTrue"></block></block></script></block></script><comment w="90" collapsed="false">Otherwise, add previously unseen neighbours to the queue.</comment></block></script></block><block s="doReport"><block s="reportNewList"><list></list></block></block></script><password></password><salt></salt></block-definition></blocks>